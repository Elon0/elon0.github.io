<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>JVM面试 - Elon的blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Elon" /><meta name="description" content="JVM 面试 栈管运行，堆管存储 JVM 垃圾回收的时候如何确定垃圾？知道什么是 GC Roots ? 什么是垃圾 简单来说就是内存中已经不在被使用到的空间就是垃圾 要进行垃圾回" /><meta name="keywords" content="Java, MySQL, Redis, Spring, Hugo, theme, even" />






<meta name="generator" content="Hugo 0.58.3 with theme even" />


<link rel="canonical" href="https://elon0.github.io/post/jvm%E9%9D%A2%E8%AF%95/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<link href="/dist/even.d314b528.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="JVM面试" />
<meta property="og:description" content="JVM 面试 栈管运行，堆管存储 JVM 垃圾回收的时候如何确定垃圾？知道什么是 GC Roots ? 什么是垃圾 简单来说就是内存中已经不在被使用到的空间就是垃圾 要进行垃圾回" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://elon0.github.io/post/jvm%E9%9D%A2%E8%AF%95/" />
<meta property="article:published_time" content="2019-09-30T14:22:00+08:00" />
<meta property="article:modified_time" content="2019-09-30T14:22:00+08:00" />
<meta itemprop="name" content="JVM面试">
<meta itemprop="description" content="JVM 面试 栈管运行，堆管存储 JVM 垃圾回收的时候如何确定垃圾？知道什么是 GC Roots ? 什么是垃圾 简单来说就是内存中已经不在被使用到的空间就是垃圾 要进行垃圾回">


<meta itemprop="datePublished" content="2019-09-30T14:22:00&#43;08:00" />
<meta itemprop="dateModified" content="2019-09-30T14:22:00&#43;08:00" />
<meta itemprop="wordCount" content="8636">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="JVM面试"/>
<meta name="twitter:description" content="JVM 面试 栈管运行，堆管存储 JVM 垃圾回收的时候如何确定垃圾？知道什么是 GC Roots ? 什么是垃圾 简单来说就是内存中已经不在被使用到的空间就是垃圾 要进行垃圾回"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Elon的blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于我</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Elon的blog</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于我</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">JVM面试</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-09-30 14:22 </span>
        
          <span class="more-meta"> 约 8636 字 </span>
          <span class="more-meta"> 预计阅读 18 分钟 </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次阅读 </span>
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li><a href="#jvm-面试">JVM 面试</a>
<ul>
<li><a href="#jvm-垃圾回收的时候如何确定垃圾-知道什么是-gc-roots">JVM 垃圾回收的时候如何确定垃圾？知道什么是 GC Roots ?</a></li>
<li><a href="#你说你做过-jvm-调优和参数配置-请问如果盘点查看-jvm-系统默认值">你说你做过 JVM 调优和参数配置，请问如果盘点查看 JVM 系统默认值？</a>
<ul>
<li><a href="#jvm-的参数类型">JVM 的参数类型</a></li>
<li><a href="#盘点家底查看-jvm-默认值">盘点家底查看 JVM 默认值</a></li>
</ul></li>
<li><a href="#你平时工作用过的-jvm-常用的基本配置参数有哪些">你平时工作用过的 JVM 常用的基本配置参数有哪些？</a></li>
<li><a href="#强引用-软引用-弱引用和虚引用分别是什么">强引用、软引用、弱引用和虚引用分别是什么？</a></li>
<li><a href="#请谈谈你对-oom-的认识">请谈谈你对 OOM 的认识？</a></li>
<li><a href="#gc-垃圾回收算法和垃圾收集器的关系-谈谈你的理解">GC 垃圾回收算法和垃圾收集器的关系？谈谈你的理解？</a></li>
<li><a href="#怎么查看服务器默认垃圾收集器是哪个-生产是如何配置垃圾收集器-谈谈你对垃圾收集器的理解">怎么查看服务器默认垃圾收集器是哪个？生产是如何配置垃圾收集器？谈谈你对垃圾收集器的理解？</a></li>
<li><a href="#g1-垃圾收集器你了解吗">G1 垃圾收集器你了解吗？</a>
<ul>
<li><a href="#region">Region</a></li>
</ul></li>
<li><a href="#jvmgc结合springboot微服务优化">JVMGC结合SpringBoot微服务优化</a></li>
<li><a href="#生产环境服务器变慢-诊断思路和性能评估谈谈">生产环境服务器变慢，诊断思路和性能评估谈谈？</a></li>
<li><a href="#假如生产环境出现-cpu-过高-请谈谈你的分析思路和定位">假如生产环境出现 CPU 过高，请谈谈你的分析思路和定位？</a></li>
<li><a href="#对于-jdk-自带的-jvm-监控和性能分析工具用过哪些-一般机是怎么用到的">对于 JDK 自带的 JVM 监控和性能分析工具用过哪些？一般机是怎么用到的？</a></li>
<li><a href="#参考链接">参考链接</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>
    <div class="post-content">
      

<h1 id="jvm-面试">JVM 面试</h1>

<blockquote>
<p>栈管运行，堆管存储</p>
</blockquote>

<h2 id="jvm-垃圾回收的时候如何确定垃圾-知道什么是-gc-roots">JVM 垃圾回收的时候如何确定垃圾？知道什么是 GC Roots ?</h2>

<ul>
<li>什么是垃圾

<ul>
<li>简单来说就是内存中已经不在被使用到的空间就是垃圾</li>
</ul></li>
<li>要进行垃圾回收，如何判断一个对象是否可以被回收？

<ul>
<li>引用计数法</li>
<li>枚举根节点做可达性分析</li>
</ul></li>
</ul>

<p>为了解决引用计数法的循环引用问题，Java 使用了可达性算法。</p>

<p><a href="http://blog.cuzz.site/2019/05/10/JVM面试/1350633405_4538.jpg"><img src="http://blog.cuzz.site/2019/05/10/JVM%E9%9D%A2%E8%AF%95/1350633405_4538.jpg" alt="img" /></a></p>

<p>跟踪收集器采用的为集中式的管理方式，全局记录对象之间的引用状态，执行时从一系列GC Roots的对象做为起点，从这些节点向下开始进行搜索所有的引用链，当一个对象到GC Roots 没有任何引用链时，则证明此对象是不可用的。</p>

<p>图中，对象Object6、Object7、Object8虽然互相引用，但他们的GC Roots是不可到达的，所以它们将会被判定为是可回收的对象。</p>

<p>哪些对象可以作为 GC Roots 的对象：</p>

<ul>
<li>虚拟机栈（栈帧中的局部变量区，也叫局部变量表）中引用的对象</li>
<li>方法区中的类静态属性引用的对象(<strong>static</strong>)</li>
<li>方法去常量引用的对象(<strong>static final</strong>)</li>
<li>本地方法栈中 JNI (Native方法)引用的对象</li>
</ul>

<h2 id="你说你做过-jvm-调优和参数配置-请问如果盘点查看-jvm-系统默认值">你说你做过 JVM 调优和参数配置，请问如果盘点查看 JVM 系统默认值？</h2>

<h3 id="jvm-的参数类型">JVM 的参数类型</h3>

<ul>
<li><p>标配参数</p>

<ul>
<li>-version</li>
<li>-help</li>
</ul></li>

<li><p>X 参数（了解）</p>

<ul>
<li>-Xint：解释执行</li>
<li>-Xcomp：第一次使用就编译成本地代码</li>
<li>-Xmixed：混合模式</li>
</ul></li>

<li><p>XX 参数</p>

<ul>
<li><p>Boolean 类型：-XX：+ 或者 - 某个属性值（+ 表示开启，- 表示关闭）</p></li>

<li><p>-XX:+PrintGCDetails：打印 GC 收集细节</p></li>

<li><p>-XX:-PrintGCDetails：不打印 GC 收集细节</p></li>

<li><p>-XX:+UseSerialGC：使用了串行收集器</p></li>

<li><p>-XX:-UseSerialGC：不使用了串行收集器</p></li>

<li><p>KV 设置类型：-XX:key=value</p></li>

<li><p>-XX:MetaspaceSize=128m</p></li>

<li><p>-XX:MaxTenuringThreshold=15</p></li>

<li><p>jinfo 举例，如何查看当前运行程序的配置</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">class</span> <span class="n">HelloGC</span> <span class="p">{</span>
<span class="kd">public</span> <span class="nf">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="p">[]</span> <span class="nf">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;hello GC...&#34;</span><span class="p">);</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="n">Thread</span><span class="p">.</span><span class="na">sleep</span><span class="p">(</span><span class="n">Integer</span><span class="p">.</span><span class="na">MAX_VALUE</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">InterruptedException</span> <span class="nf">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div></li>
</ul>

<p>我们可以使用 <code>jps -l</code> 命令，查出进程 id</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></pre></td>
<td class="lntd">
<pre class="chroma">1923 org.jetbrains.jps.cmdline.Launcher
1988 sun.tools.jps.Jps
1173 org.jetbrains.kotlin.daemon.KotlinCompileDaemon
32077 com.intellij.idea.Main
1933 com.cuzz.jvm.HelloGC
32382 org.jetbrains.idea.maven.server.RemoteMavenServer</pre></td></tr></table>
</div>
</div>
<p>在使用 <code>jinfo -flag PrintGCDetails 1933</code> 命令查看</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span></pre></td>
<td class="lntd">
<pre class="chroma">-XX:-PrintGCDetails</pre></td></tr></table>
</div>
</div>
<p>可以看出默认是不打印 GC 收集细节
也可是使用<code>jinfo -flags 1933</code> 查看所有的参数</p>

<ul>
<li><p>两个经典参数：-Xms 和 - Xmx（如 -Xms1024m）</p></li>

<li><p><strong>-Xms 等价于 -XX:InitialHeapSize</strong></p></li>

<li><p><strong>-Xmx 等价于 -XX:MaxHeapSize</strong></p></li>
</ul></li>
</ul>

<h3 id="盘点家底查看-jvm-默认值">盘点家底查看 JVM 默认值</h3>

<ul>
<li><p>查看初始默认值：-XX:+PrintFlagsInitial</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></pre></td>
<td class="lntd">
<pre class="chroma">cuzz@cuzz-pc:~/Project/demo$ java -XX:+PrintFlagsInitial
[Global flags]
   intx ActiveProcessorCount                      = -1                                  {product}
  uintx AdaptiveSizeDecrementScaleFactor          = 4                                   {product}
  uintx AdaptiveSizeMajorGCDecayTimeScale         = 10                                  {product}
  uintx AdaptiveSizePausePolicy                   = 0                                   {product}
  uintx AdaptiveSizePolicyCollectionCostMargin    = 50                                  {product}
  uintx AdaptiveSizePolicyInitializingSteps       = 20                                  {product}
  uintx AdaptiveSizePolicyOutputInterval          = 0                                   {product}
  uintx AdaptiveSizePolicyWeight                  = 10                                  {product}
 ...</pre></td></tr></table>
</div>
</div></li>

<li><p>查看修改更新：-XX:+PrintFlagsFinal</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></pre></td>
<td class="lntd">
<pre class="chroma">bool UsePSAdaptiveSurvivorSizePolicy           = true                                {product}
bool UseParNewGC                               = false                               {product}
bool UseParallelGC                            := true                                {product}
bool UseParallelOldGC                          = true                                {product}
bool UsePerfData                               = true                                {product}
bool UsePopCountInstruction                    = true                                {product}
bool UseRDPCForConstantTableBase               = false                               {C2 product}</pre></td></tr></table>
</div>
</div></li>
</ul>

<p>= 与 := 的区别是，一个是默认，一个是人物改变或者 jvm 加载时改变的参数</p>

<ul>
<li><p>打印命令行参数(可以看默认垃圾回收器)：-XX:+PrintCommandLineFlags</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span></pre></td>
<td class="lntd">
<pre class="chroma">cuzz@cuzz-pc:~/Project/demo$ java -XX:+PrintCommandLineFlags
-XX:InitialHeapSize=128789376 -XX:MaxHeapSize=2060630016 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC</pre></td></tr></table>
</div>
</div></li>
</ul>

<h2 id="你平时工作用过的-jvm-常用的基本配置参数有哪些">你平时工作用过的 JVM 常用的基本配置参数有哪些？</h2>

<ul>
<li><p>-Xms</p>

<ul>
<li>初始大小内存，默认为物理内存 <sup>1</sup>&frasl;<sub>64</sub></li>
<li>等价于 -XX:InitialHeapSize</li>
</ul></li>

<li><p>-Xmx</p>

<ul>
<li>最大分配内存，默认为物理内存的 <sup>1</sup>&frasl;<sub>4</sub></li>
<li>等价于 -XX:MaxHeapSize</li>
</ul></li>

<li><p>-Xss</p>

<ul>
<li>设置单个线程栈的大小，一般默认为 512-1024k</li>
<li>等价于 -XX:ThreadStackSize</li>
</ul></li>

<li><p>-Xmn</p>

<ul>
<li>设置年轻代的大小</li>
<li><strong>整个JVM内存大小=年轻代大小 + 年老代大小 + 持久代大小</strong>，持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。</li>
</ul></li>

<li><p>-XX:MetaspaceSize</p>

<ul>
<li>设置元空间大小（元空间的本质和永久代类似，都是对 JVM 规范中的方法区的实现，不过元空间于永久代之间最大区别在于，<strong>元空间并不在虚拟中，而是使用本地内存</strong>，因此默认情况下，元空间的大小仅受本地内存限制）</li>
<li>元空间默认比较小（21M），我们可以调大一点</li>
</ul></li>

<li><p>-XX:+PrintGCDetails</p>

<ul>
<li><p>输出详细 GC 收集日志信息</p></li>

<li><p>设置 JVM 参数为： -Xms10m -Xmx10m -XX:+PrintGCDetails</p></li>

<li><p>代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></pre></td>
<td class="lntd">
<pre class="chroma">public class HelloGC {
  public static void main(String[] args) {
      byte[] bytes = new byte[20 * 1024 * 1024];
  }
}</pre></td></tr></table>
</div>
</div></li>

<li><p>打印结果</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></pre></td>
<td class="lntd">
<pre class="chroma">[GC (Allocation Failure) [PSYoungGen: 1231K-&gt;448K(2560K)] 1231K-&gt;456K(9728K), 0.0015616 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[GC (Allocation Failure) [PSYoungGen: 448K-&gt;384K(2560K)] 456K-&gt;392K(9728K), 0.0016999 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[Full GC (Allocation Failure) [PSYoungGen: 384K-&gt;0K(2560K)] [ParOldGen: 8K-&gt;358K(7168K)] 392K-&gt;358K(9728K), [Metaspace: 3028K-&gt;3028K(1056768K)], 0.0066696 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] 
[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] 358K-&gt;358K(9728K), 0.0005321 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] [ParOldGen: 358K-&gt;340K(7168K)] 358K-&gt;340K(9728K), [Metaspace: 3028K-&gt;3028K(1056768K)], 0.0051543 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] 
Heap
PSYoungGen      total 2560K, used 81K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)
eden space 2048K, 3% used [0x00000000ffd00000,0x00000000ffd14668,0x00000000fff00000)
from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)
to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)
ParOldGen       total 7168K, used 340K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)
object space 7168K, 4% used [0x00000000ff600000,0x00000000ff655188,0x00000000ffd00000)
Metaspace       used 3060K, capacity 4496K, committed 4864K, reserved 1056768K
class space    used 336K, capacity 388K, committed 512K, reserved 1048576K
Exception in thread &#34;main&#34; java.lang.OutOfMemoryError: Java heap space
at com.cuzz.jvm.HelloGC.main(HelloGC.java:12)</pre></td></tr></table>
</div>
</div></li>

<li><p>GC
<a href="http://blog.cuzz.site/2019/05/10/JVM面试/a9a0eb99b30cf3fd8973f464eb4678bf50f760cc.jpg"><img src="http://blog.cuzz.site/2019/05/10/JVM%E9%9D%A2%E8%AF%95/a9a0eb99b30cf3fd8973f464eb4678bf50f760cc.jpg" alt="img" /></a></p></li>

<li><p>FullGC
<a href="http://blog.cuzz.site/2019/05/10/JVM面试/e04f3f3b68cff61027e5ba8eba9613bb7c69a08a.jpg"><img src="http://blog.cuzz.site/2019/05/10/JVM%E9%9D%A2%E8%AF%95/e04f3f3b68cff61027e5ba8eba9613bb7c69a08a.jpg" alt="img" /></a></p></li>
</ul></li>

<li><p>-XX:SurvivorRatio</p>

<ul>
<li>设置新生代中 eden 和 S0/S1 空间比例</li>
<li>默认 -XX:SurvivorRatio=8，Eden : S0 : S1 = 8 : 1 : 1</li>
</ul></li>

<li><p>-XX:NewRatio</p>

<ul>
<li>配置年轻代和老年代在堆结构的占比</li>
<li>默认 -XX:NewRatio=2 新生代占1，老年代占2，年轻代占整个堆的 <sup>1</sup>&frasl;<sub>3</sub></li>
</ul></li>

<li><p>-XX:MaxTenuringThreshold</p>

<ul>
<li>设置垃圾最大年龄</li>
</ul></li>
</ul>

<h2 id="强引用-软引用-弱引用和虚引用分别是什么">强引用、软引用、弱引用和虚引用分别是什么？</h2>

<p>在Java语言中，除了基本数据类型外，其他的都是指向各类对象的对象引用；Java中根据其生命周期的长短，将引用分为4类。</p>

<ul>
<li><p>强引用</p>

<ul>
<li>特点：当内存不足，JVM开始垃圾回收，对于强引用的对象，<strong>就算是出现了OOM也不会对该对象进行回收，死都不收</strong>。</li>
<li><strong>即使该对象以后永远都不会被用到，JVM也不会回收。</strong>因此强引用是造成Java内存泄漏的主要原因之一。</li>
<li>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，一般认为就是可以被垃圾收集的了（当然具体回收时机还是要看垃圾收集策略）。</li>
</ul></li>

<li><p>软引用</p>

<ul>
<li><p>特点：软引用是一种相对强引用弱化了一些的引用，需要用<code>java.lang.ref.SoftReference</code>类来实现。</p></li>

<li><p>对于只有软引用的对象来说，</p></li>
</ul>

<blockquote>
<p>​ <strong>当系统内存充足时它 不会  被回收，</strong></p>

<p>​ <strong>当系统内存不足时它 会       被回收。</strong></p>
</blockquote>

<ul>
<li><p>软引用通常用在内存敏感的程序中，比如高速缓存就有用到软引用，<strong>内存够用的时候就保留，不够用就回收！</strong></p></li>

<li><p>应用场景：软引用通常用来实现内存敏感的缓存。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p></li>
</ul>

<blockquote>
<p>假如有一个应用需要读取大量的本地图片：</p>

<ul>
<li>如果每次读取图片都从硬盘读取则会严重影响性能，</li>
<li>如果一次性全部加载到内存中又可能造成内存溢出。</li>
</ul>

<p>此时使用软引用可以解决这个问题。</p>

<p>​ 设计思路是：用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM问题。</p>

<p><code>Map&lt;String, SoftReference&lt;Bitmap&gt;&gt; imageCache = new HashMap&lt;&gt;();</code></p>
</blockquote>

<ul>
<li><p>代码验证</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="c1">//我设置 JVM 参数为 -Xms10m -Xmx10m -XX:+PrintGCDetails
</span><span class="c1"></span><span class="kd">public</span> <span class="nf">class</span> <span class="n">SoftReferenceDemo</span> <span class="p">{</span>
  <span class="kd">public</span> <span class="nf">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="p">[]</span> <span class="nf">args</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Object</span> <span class="nf">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="p">();</span>
      <span class="n">SoftReference</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="nf">softReference</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SoftReference</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
      <span class="n">obj</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    
      <span class="k">try</span> <span class="p">{</span>
          <span class="c1">// 分配 20 M
</span><span class="c1"></span>          <span class="kt">byte</span><span class="p">[]</span> <span class="nf">bytes</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="p">[</span><span class="n">20</span> <span class="o">*</span> <span class="n">1024</span> <span class="o">*</span> <span class="n">1024</span><span class="p">];</span>
      <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="nf">e</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">e</span><span class="p">.</span><span class="na">printStackTrace</span><span class="p">();</span>
      <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
          <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;软引用：&#34;</span> <span class="o">+</span> <span class="n">softReference</span><span class="p">.</span><span class="na">get</span><span class="p">());</span>
      <span class="p">}</span>
    
  <span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div></li>

<li><p>输出</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></pre></td>
<td class="lntd">
<pre class="chroma">[GC (Allocation Failure) [PSYoungGen: 1234K-&gt;448K(2560K)] 1234K-&gt;456K(9728K), 0.0016748 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
[GC (Allocation Failure) [PSYoungGen: 448K-&gt;384K(2560K)] 456K-&gt;392K(9728K), 0.0018398 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
[Full GC (Allocation Failure) [PSYoungGen: 384K-&gt;0K(2560K)] [ParOldGen: 8K-&gt;358K(7168K)] 392K-&gt;358K(9728K), [Metaspace: 3030K-&gt;3030K(1056768K)], 0.0057246 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] 
[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] 358K-&gt;358K(9728K), 0.0006038 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] [ParOldGen: 358K-&gt;340K(7168K)] 358K-&gt;340K(9728K), [Metaspace: 3030K-&gt;3030K(1056768K)], 0.0115080 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] 
软引用：null
Exception in thread &#34;main&#34; java.lang.OutOfMemoryError: Java heap space
at com.cuzz.jvm.SoftReferenceDemo.main(SoftReferenceDemo.java:21)
Heap
PSYoungGen      total 2560K, used 98K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)
eden space 2048K, 4% used [0x00000000ffd00000,0x00000000ffd18978,0x00000000fff00000)
from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)
to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)
ParOldGen       total 7168K, used 340K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)
object space 7168K, 4% used [0x00000000ff600000,0x00000000ff6552f8,0x00000000ffd00000)
Metaspace       used 3067K, capacity 4496K, committed 4864K, reserved 1056768K
class space    used 336K, capacity 388K, committed 512K, reserved 1048576K</pre></td></tr></table>
</div>
</div></li>
</ul>

<p>发现当内存不够的时候就会被回收。</p></li>

<li><p>弱引用</p>

<ul>
<li><p>特点：弱引用需要用<code>java.lang.ref.WeakReference</code>类来实现。 弱引用的生命周期比软引用短。</p></li>

<li><p>对于只有弱引用的对象来说，只要垃圾回收机制一运行，<strong>不管JVM的内存空间是否足够，都会回收该对象占用的内存。</strong></p></li>

<li><p>应用场景：弱应用同样可用于内存敏感的缓存。</p></li>

<li><p>代码验证</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">class</span> <span class="n">WeakReferenceDemo</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="nf">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="p">[]</span> <span class="nf">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Object</span> <span class="nf">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="p">();</span>
        <span class="n">WeakReference</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="nf">weakReference</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WeakReference</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">weakReference</span><span class="p">.</span><span class="na">get</span><span class="p">());</span>
    
        <span class="n">obj</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
        <span class="n">System</span><span class="p">.</span><span class="na">gc</span><span class="p">();</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;GC之后....&#34;</span><span class="p">);</span>
    
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">weakReference</span><span class="p">.</span><span class="na">get</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div></li>

<li><p>输出</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></pre></td>
<td class="lntd">
<pre class="chroma">java.lang.Object@1540e19d
java.lang.Object@1540e19d
GC之后....
null
null</pre></td></tr></table>
</div>
</div></li>

<li><p>值得注意的是<code>String name = &quot;cuzz&quot;</code> 这种会放入永久代，以及 <code>Integer age = 1</code> 在 int 中 -128 到 127 会被缓存，所以是强引用，然后 GC 也不会被回收。</p></li>

<li><p>引用队列</p></li>
</ul>

<p><strong>我在回收前需要被引用队列保存下。</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">class</span> <span class="n">ReferenceQueueDemo</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="nf">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="p">[]</span> <span class="nf">args</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">InterruptedException</span> <span class="p">{</span>
        <span class="n">Object</span> <span class="nf">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="p">();</span>
        <span class="n">ReferenceQueue</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="nf">referenceQueue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReferenceQueue</span><span class="o">&lt;&gt;</span><span class="p">();</span>
        <span class="n">WeakReference</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="nf">weakReference</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WeakReference</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">referenceQueue</span><span class="p">);</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">weakReference</span><span class="p">.</span><span class="na">get</span><span class="p">());</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">referenceQueue</span><span class="p">.</span><span class="na">poll</span><span class="p">());</span>
    
        <span class="n">obj</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
        <span class="n">System</span><span class="p">.</span><span class="na">gc</span><span class="p">();</span>
        <span class="n">Thread</span><span class="p">.</span><span class="na">sleep</span><span class="p">(</span><span class="n">500</span><span class="p">);</span>
    
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;GC之后....&#34;</span><span class="p">);</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">weakReference</span><span class="p">.</span><span class="na">get</span><span class="p">());</span>
        <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">referenceQueue</span><span class="p">.</span><span class="na">poll</span><span class="p">());</span>
        <span class="c1">//也就是gc后被放入引用队列了
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></pre></td>
<td class="lntd">
<pre class="chroma">    
输出
    </pre></td></tr></table>
</div>
</div>
<p>java.lang.Object@27c170f0
java.lang.Object@27c170f0
null
GC之后&hellip;.
null
null
java.lang.ref.WeakReference@5451c3a8</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span></pre></td>
<td class="lntd">
<pre class="chroma">    
会把该对象的包装类即`weakReference`放入到`ReferenceQueue`里面，我们可以从queue中获取到相应的对象信息，同时进行额外的处理。比如反向操作，数据清理等。</pre></td></tr></table>
</div>
</div></li>

<li><p>虚引用</p>

<ul>
<li><p>特点：虚引用需要<code>java.lang.ref.PhantomReference</code>类来实现。</p></li>

<li><p>顾名思义，<strong>就是形同虚设</strong>，与其他几种引用都不同，虚引用并不会决定对象的生命周期。</p></li>

<li><p><strong>如果一个对象仅持有虚引用，那么他就和没有任何引用一样，在任何时候都可能被垃圾回收器回收，</strong>它不能单独使用也不能通过它访问对象，虚引用必须和引用队列（ReferenceQueue）联合使用。</p></li>

<li><p>虚引用的主要作用是跟踪对象被垃圾回收的状态。仅仅是提供了一种确保对象被finalize以后，做某些事的机制。PhantomReference的get方法总是返回null，因此无法访问对应的引用对象。其意义在于说明一个对象已经进入finalization阶段，可以被gc回收，用来实现比finalization机制更灵活的回收操作。</p></li>

<li><p>换句话说，设置虚引用关联的唯一目的，就是在这个对象被收集器回收的时候收到一个系统通知或者后序添加进一步的处理。Java技术运行使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。</p></li>

<li><p>应用场景：可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">class</span> <span class="n">PhantomReferenceDemo</span> <span class="p">{</span>
<span class="kd">public</span> <span class="nf">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="p">[]</span> <span class="nf">args</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">InterruptedException</span> <span class="p">{</span>
    <span class="n">Object</span> <span class="nf">o1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="p">();</span>
    <span class="n">ReferenceQueue</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="nf">referenceQueue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReferenceQueue</span><span class="o">&lt;&gt;</span><span class="p">();</span>
    <span class="n">PhantomReference</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="nf">phantomReference</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PhantomReference</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">o1</span><span class="p">,</span> <span class="n">referenceQueue</span><span class="p">);</span>
    <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">o1</span><span class="p">);</span>
    <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">phantomReference</span><span class="p">.</span><span class="na">get</span><span class="p">());</span>
    <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">referenceQueue</span><span class="p">.</span><span class="na">poll</span><span class="p">());</span>
    
    <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;==================&#34;</span><span class="p">);</span>
    <span class="n">o1</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
    <span class="n">System</span><span class="p">.</span><span class="na">gc</span><span class="p">();</span>
    <span class="n">Thread</span><span class="p">.</span><span class="na">sleep</span><span class="p">(</span><span class="n">500</span><span class="p">);</span>
    
    <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">o1</span><span class="p">);</span>
    <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">phantomReference</span><span class="p">.</span><span class="na">get</span><span class="p">());</span>
    <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">referenceQueue</span><span class="p">.</span><span class="na">poll</span><span class="p">());</span>
            
<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div></li>

<li><p>输出</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></pre></td>
<td class="lntd">
<pre class="chroma">java.lang.Object@27c170f0
null
null
==================
null
null
java.lang.ref.PhantomReference@5451c3a8</pre></td></tr></table>
</div>
</div></li>
</ul></li>

<li><p><strong>总结</strong></p></li>
</ul>

<p>java提供了4中引用类型，在立即护手的时候，都有自己的特点。</p>

<p>ReferenceQueue是用来配合引用工作的，没有ReferenceQueue一样可以运行。</p>

<p>创建引用的时候可以指定关联的队列，当GC释放对象内存的时候，会将引用加入引用队列，如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动，这相当于是一种通知机制。</p>

<p>当关联的引用队列中有数据的时候，意味着引用指向的堆内存中的对象被回收。通过这组方式，JVM允许我们在对象被销毁后，做一些我们自己想做的事情。</p>

<h2 id="请谈谈你对-oom-的认识">请谈谈你对 OOM 的认识？</h2>

<ul>
<li><p>java.lang.StackOverflowError</p>

<ul>
<li>在一个函数中调用自己就会产生这个错误</li>
</ul></li>

<li><p>java.lang.OutOfMemoryError : Java heap space</p>

<ul>
<li>new 一个很大对象。<code>byte[] bytes = new byte[80*1024*1024];</code></li>
</ul></li>

<li><p>java.lang.OutOfMemoryError : GC overhead limit exceeded</p>

<ul>
<li>执行垃圾收集的时间比例太大， 有效的运算量太小，默认情况下,，如果GC花费的时间超过 <strong>98%</strong>， 并且GC回收的内存少于 <strong>2%</strong>， JVM就会抛出这个错误。</li>
</ul></li>

<li><p>java.lang.OutOfMemoryError : Direct buffer memory</p></li>
</ul>

<p>在NIO程序中经常出现。</p>

<p>NIO，使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。</p>

<p>配置参数：-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=5m</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">  <span class="cm">/**
</span><span class="cm">   * @Author: Elon
</span><span class="cm"> * @Date: 2019-10-01 23:50
</span><span class="cm">   *
</span><span class="cm"> * 配置参数
</span><span class="cm">   * -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=5m
</span><span class="cm">   *
</span><span class="cm">   * 故障现象
</span><span class="cm">   * Exception in thread &#34;main&#34; java.lang.OutOfMemoryError: Direct buffer memory
</span><span class="cm">   *
</span><span class="cm">   * 导致原因
</span><span class="cm">   * 写NIO程序，它经常可以用Native函数库直接分配堆外内存，这样性能高，因为避免了在Java堆和Native堆中来回复制数据。
</span><span class="cm">   *
</span><span class="cm">   * ByteBuffer.allocate(capability);     第一种方式是分配JVM堆内存，属于GC管辖范围，由于需要拷贝所以速度相对较慢。
</span><span class="cm">   *
</span><span class="cm">   * ByteBuffer.allocateDirect(capability);   第二种方式是分配OS本地内存，不属于GC管辖范围，由于不需要内存拷贝所以速度相对较快。
</span><span class="cm">   *
</span><span class="cm">   * 但如果不断分配本地内存，堆内存很少使用，那么JVM就不需要执行GC，DirectByteBuffer对象们就不会被回收，
</span><span class="cm">   * 这时候堆内存充足，但本地内存可能已经使用光了，再次尝试分配本地内存就会出现OutOfMemoryError，那程序就直接奔溃了。
</span><span class="cm">   */</span>
  <span class="kd">public</span> <span class="nf">class</span> <span class="n">DirectBufferMemoryDemo</span> <span class="p">{</span>
      <span class="kd">public</span> <span class="nf">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="p">[]</span> <span class="nf">args</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;maxDirectMemory : &#34;</span> <span class="o">+</span> <span class="n">sun</span><span class="p">.</span><span class="na">misc</span><span class="p">.</span><span class="na">VM</span><span class="p">.</span><span class="na">maxDirectMemory</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="n">1024</span> <span class="o">*</span> <span class="n">1024</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34;MB&#34;</span><span class="p">);</span>
          <span class="c1">// -XX:MaxDirectMemorySize=5m   我们配置为5MB，但实际使用6MB，故意使坏
</span><span class="c1"></span>        <span class="n">ByteBuffer</span> <span class="nf">byteBuffer</span> <span class="o">=</span> <span class="n">ByteBuffer</span><span class="p">.</span><span class="na">allocateDirect</span><span class="p">(</span><span class="n">6</span> <span class="o">*</span> <span class="n">1024</span> <span class="o">*</span> <span class="n">1024</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>输出</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></pre></td>
<td class="lntd">
<pre class="chroma">  maxDirectMemory : 5MB
  [GC (System.gc()) [PSYoungGen: 1315K-&gt;464K(2560K)] 1315K-&gt;472K(9728K), 0.0008907 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
  [Full GC (System.gc()) [PSYoungGen: 464K-&gt;0K(2560K)] [ParOldGen: 8K-&gt;359K(7168K)] 472K-&gt;359K(9728K), [Metaspace: 3037K-&gt;3037K(1056768K)], 0.0060466 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
  Exception in thread &#34;main&#34; java.lang.OutOfMemoryError: Direct buffer memory
  	at java.nio.Bits.reserveMemory(Bits.java:694)
  	at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:123)
  	at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:311)
  	at com.cuzz.jvm.DirectBufferDemo.main(DirectBufferDemo.java:17)
  Heap
   PSYoungGen      total 2560K, used 56K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)
    eden space 2048K, 2% used [0x00000000ffd00000,0x00000000ffd0e170,0x00000000fff00000)
    from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)
    to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)
   ParOldGen       total 7168K, used 359K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)
    object space 7168K, 5% used [0x00000000ff600000,0x00000000ff659e28,0x00000000ffd00000)
   Metaspace       used 3068K, capacity 4496K, committed 4864K, reserved 1056768K
    class space    used 336K, capacity 388K, committed 512K, reserved 1048576K</pre></td></tr></table>
</div>
</div>
<ul>
<li><p>java.lang.OutOfMemoryError : unable to create new native thread</p>

<ul>
<li>创建线程数太多了</li>
</ul></li>
</ul>

<p>github图床</p>

<p><img src="https://raw.githubusercontent.com/Elon0/img/master/pictures/20191002000923.png" alt="" /></p>

<p>本地</p>

<p><img src="/Users/chengrong/Library/Application Support/typora-user-images/image-20191002001250224.png" alt="image-20191002001250224" /></p>

<ul>
<li><p>java.lang.OutOfMemoryError : Metaspace</p>

<ul>
<li>Java 8 之后的版本使用元空间（Metaspace）代替了永久代，元空间是方法区在 HotSpot 中的实现，它与永久代最大的区别是：元空间并不在虚拟机中的内存中而是使用本地内存。</li>
<li>元空间存放的信息：</li>
<li>虚拟机加载的类信息</li>
<li>常量池</li>
<li>静态变量</li>
<li>即时编译后的代码</li>
</ul></li>
</ul>

<p>具体的实现可以看看这个帖子：<a href="http://www.dataguru.cn/thread-351920-1-1.html">几种手动OOM的方式</a></p>

<h2 id="gc-垃圾回收算法和垃圾收集器的关系-谈谈你的理解">GC 垃圾回收算法和垃圾收集器的关系？谈谈你的理解？</h2>

<ul>
<li>四种 GC 垃圾回收算法

<ul>
<li>引用计数</li>
<li>复制回收</li>
<li>标记清除</li>
<li>标记整理</li>
</ul></li>
<li>GC 算法是内存回收的方法论，垃圾收集其就是算法的落实的实现。</li>
<li>目前为止还没有完美的收集器的出现，更加没有万能的收集器，只是针对具体应用最适合的收集器，进行分代收集。</li>
<li>串行垃圾回收器（Serial）

<ul>
<li>它为单线程环境设计且只使用一个线程进行垃圾回收，会暂停所有的用户线程，所以不适合服务器环境。</li>
</ul></li>
<li>并行垃圾回收器（Parallel）

<ul>
<li>多个垃圾收集线程并行工作，此时用户线程是暂停的，用于科学计算、大数据处理等弱交互场景。</li>
</ul></li>
<li>并发垃圾回收器（CMS）

<ul>
<li>用户线程和垃圾收集线程同时执行（不一定是并行，可能是交替执行），不需要停顿用户线程，互联网公司多用它，适用对相应时间有要求的场景。</li>
</ul></li>
<li>G1 垃圾回收器

<ul>
<li>G1 垃圾回收器将堆内存分割成不同的区域然后并发的对其进行垃圾回收。</li>
</ul></li>
</ul>

<h2 id="怎么查看服务器默认垃圾收集器是哪个-生产是如何配置垃圾收集器-谈谈你对垃圾收集器的理解">怎么查看服务器默认垃圾收集器是哪个？生产是如何配置垃圾收集器？谈谈你对垃圾收集器的理解？</h2>

<ul>
<li><p>怎么查看服务器默认垃圾收集器是哪个？</p>

<ul>
<li>Java -XX:+PrintCommandLineFlags</li>
</ul></li>

<li><p>Java 的 GC 回收的类型主要有：</p>

<ul>
<li>UseSerialGC，UseParallelGC，UseConcMarkSweepGC，UseParNewGC，UseParallelOldGC，UseG1GC</li>
<li>Java 8 以后基本不使用 Serial Old</li>
</ul></li>

<li><p>垃圾收集器
<a href="http://blog.cuzz.site/2019/05/10/JVM面试/timg.jpg"><img src="http://blog.cuzz.site/2019/05/10/JVM%E9%9D%A2%E8%AF%95/timg.jpg" alt="timg" /></a></p></li>

<li><p>参数说明</p>

<ul>
<li>DefNew : Default New Generation</li>
<li>Tenured : Old</li>
<li>ParNew : Parallel New Generation</li>
<li>PSYoungGen : Parallel Scavenge</li>
<li>ParOldGen : Parallel Old Generation</li>
</ul></li>

<li><p>Server/Client 模式分别是什么意思</p>

<ul>
<li>最主要的差别在于：-Server模式启动时，速度较慢，但是一旦运行起来后，性能将会有很大的提升。</li>
<li>当虚拟机运行在-client模式的时候，使用的是一个代号为C1的轻量级编译器, 而-server模式启动的虚拟机采用相对重量级，代号为C2的编译器，C2比C1编译器编译的相对彻底，服务起来之后,性能更高。</li>
<li>所以通常用于做服务器的时候我们用服务端模式，如果你的电脑只是运行一下java程序，就客户端模式就可以了。当然这些都是我们做程序优化程序才需要这些东西的，普通人并不关注这些专业的东西了。其实服务器模式即使编译更彻底，然后垃圾回收优化更好，这当然吃的内存要多点相对于客户端模式。</li>
</ul></li>

<li><p>新生代</p>

<ul>
<li>串行 GC (Serial/ Serial Copying)</li>
<li>并行 GC (ParNew)</li>
<li>并行回收 GC (Parallel/ Parallel Scavenge)
<br /></li>
</ul></li>
</ul>

<blockquote>
<p>SerialGC， Heap {def new generation，tenured generation，Metaspace}</p>

<p>ParNew， Heap {par new generation，tenured generation，Metaspace}</p>

<p>Parallel Scavenge 新生代老年代都并行化， PSYoungGen，ParOldGen</p>
</blockquote>

<ul>
<li>老年代

<ul>
<li>串行 GC (Serial Old/ Serial MSC)</li>
<li>并行 GC (Parallel Old/ Parallel MSC)</li>
<li>并发标记清除 GC (CMS)</li>
<li><strong>是一种以获取最短回收停顿时间为目标的收集器</strong>，适合应用在互联网站或者 B/S 系统的服务器上，这个类应用尤其重视服务器的响应速度，<strong>希望系统停顿时间最短</strong>。</li>
<li>CMS 非常适合堆内存大、CPU 核数多的服务器端应用，也是 G1 出现之前大型应用首选收集器。</li>
<li><strong>并发停顿比较少，并发指的是与用户线程一起执行。</strong></li>
<li>过程

<ul>
<li>初始标记（initial mark）：只是标记一下 GC Roots 能直接关联的对象，速度很快，需要暂停所有的工作线程</li>
<li>并发标记（concurrent mark 和用户线程一起）：进行 GC Roots 的跟踪过程，和用户线程一起工作，不需要暂停工作线程。</li>
<li>重新标记（remark）：为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。</li>
<li>并发清除（concurrent sweep 和用户线程一起）：清除 GC Roots不可达对象，和用户线程一起工作，不需要暂停工作线程，基于标记结果，直接清除。由于耗时最长的并发标记和并发清除过程中，垃圾收集线程和用户线程可以一起并发工作，所以总体来看 CMS 收集器的内存回收和用户线程是一起并发地执行。</li>
</ul></li>
<li>优缺点

<ul>
<li>优点：并发收集停顿低</li>
<li>缺点：并发执行对 CPU 资源压力大，采用的标记清除算法会导致大量碎片</li>
</ul></li>
<li>由于并发进行， CMS 在收集与应用线程会同时增加对堆内存的占用，也就是说，CMS 必须要在老年代堆用尽之前完成垃圾回收，否者 CMS 回收失败，抛出“Concurrent Mode Failure”，JVM临时启用串行老年代收集器将会以 STW 的方式进行一次 GC，从而造成较大的停顿时间。</li>
<li>标记清除算法无法整理空间碎片，老年代空间会随着应用时长被逐渐耗尽，最后将不得不通过担保机制对堆内存进行压缩。CMS 也提供了参数 -XX:CMSFullGCsBeForeCompaction (默认0，即每次都进行内存整理) 来指定多少次 CMS 收集之后，进行一次压</li>
</ul></li>
<li>垃圾收集器配置代码总结

<ul>
<li>配置新生代收集器，老年代收集器会自动配置上。
<a href="http://blog.cuzz.site/2019/05/10/JVM面试/1558237229584.png"><img src="http://blog.cuzz.site/2019/05/10/JVM%E9%9D%A2%E8%AF%95/1558237229584.png" alt="1558237229584" /></a></li>
</ul></li>
<li>如何选择垃圾收集器

<ul>
<li>单 CPU 或者小内存，单机程序：-XX:UseSerialGC</li>
<li>多 CPU 需要最大吞吐量，如后台计算型应用：-XX:UseParallelGC 或者 -XX:UseParallelOldGC</li>
<li>多 CPU 追求低停顿时间，需要快速响应，如互联网应用：-XX:+UseConcMarkSweepGC</li>
</ul></li>
</ul>

<h2 id="g1-垃圾收集器你了解吗">G1 垃圾收集器你了解吗？</h2>

<ul>
<li><p>以前收集器的特点</p>

<ul>
<li>年轻代和老年代是各自独立且连续的内存块</li>
<li>年轻代收集器使用 eden + S0 + S1 进行复制算法</li>
<li>老年代收集必须扫描整个老年代区域</li>
<li>都是以尽可能的少而快速地执行 GC 为设计原则</li>
</ul></li>

<li><p>G1 是什么</p>

<ul>
<li>G1 是一种面向服务端的垃圾收集器，应用在多核处理器和大容量内存环境中，在实现高吞吐量的同时，尽可能的满足垃圾收集器的暂停时间要求。</li>
<li>像 CMS 收集器一样，能与应用程序线程并发执行，整理空闲空间更快，需要更多的时间来预测 GC 停顿时间，不希望牺牲大量的吞吐性能，不需要更大的 Java Heap。</li>
<li>G1 收集器的设计目的是取代 CMS 收集器，同时与 CMS 相比，G1 垃圾收集器是一个有整理内存过程的垃圾收集器，不会产生很多内存碎片。G1 的 Stop The World 更可控，G1 在停顿上添加了预测机制，用户可以指定期望的停顿时间。</li>
<li>G1 是在 2012 年才在 jdk.1.7u4 中可以呀用，在 jdk9 中将 G1 变成默认垃圾收集器来代替 CMS。它是以款面向服务应用的收集器。</li>
<li>主要改变是 Eden、Survivor 和 Tenured 等内存区域不再是连续的，而是变成了一个个大小一样的 region，每个 region 从 1M 到 32M 不等，一个 region 有可能属于 Eden、Survivor 或者 Tenured 内存区域。</li>
</ul></li>

<li><p>特点</p>

<ol>
<li><p>G1 能充分利用多 CPU、多核环境硬件优势，尽量缩短 STW。</p></li>

<li><p>G1 整体采用标记-整理算法，局部是通过是通过复制算法，<strong>不会产生内存碎片</strong>。</p></li>

<li><p>宏观上看 G1 之中不再区分年轻代和老年代，<strong>把内存划分为多个独立的子区域(Region)</strong>，可以近似理解为一个棋盘。</p></li>

<li><p>G1 收集器里面将整个的内存区域混合在一起，<strong>但其本身依然在小范围内要进行年轻代和老年代的区分</strong>。保留了新生代和老年代，但她们不在是物理隔离，而是一部分 Region 的集合且不需要 Region 是连续的，也就是说依然会采用不同的 GC 方式来处理不同的区域。</p></li>

<li><p>G1 虽然也是分代收集器，但整个内存分区<strong>不存在物理上的</strong>年轻代和老年代的区别，也不需要完全独立的 Survivor to space 堆做复制准备。<strong>G1 只有逻辑上的分代概念</strong>，或者说每个分区都可能随 G1 的运行在不同代之间前后切换。</p></li>
</ol></li>

<li><p>底层原理</p>

<ul>
<li><p>Region 区域化垃圾收集器：最大好处是化整为零，避免全内存扫描，只需要按照区域来进行扫描即可。</p></li>

<li><h3 id="region">Region</h3></li>
</ul>

<p><a href="http://blog.cuzz.site/2019/05/10/JVM面试/5611237-f643066bd97c7703.png"><img src="http://blog.cuzz.site/2019/05/10/JVM%E9%9D%A2%E8%AF%95/5611237-f643066bd97c7703.png" alt="5611237-f643066bd97c7703" /></a>
G1的内存结构和传统的内存空间划分有比较的不同。G1将内存划分成了多个大小相等的Region（默认是512K），Region逻辑上连续，物理内存地址不连续。同时每个Region被标记成E、S、O、H，分别表示Eden、Survivor、Old、Humongous。其中E、S属于年轻代，O与H属于老年代。
H表示Humongous。从字面上就可以理解表示大的对象（下面简称H对象）。<strong>当分配的对象大于等于Region大小的一半</strong>的时候就会被认为是巨型对象。H对象默认分配在老年代，可以防止GC的时候大对象的内存拷贝。通过如果发现堆内存容不下H对象的时候，会触发一次GC操作。</p>

<ul>
<li><p>回收步骤</p></li>

<li><p>参看：<a href="https://www.jianshu.com/p/548c67aa1bc0">G1从入门到放弃</a></p></li>

<li><p>四步过程
<a href="http://blog.cuzz.site/2019/05/10/JVM面试/u=1236259389,1737476709&amp;fm=26&amp;gp=0.jpg"><img src="http://blog.cuzz.site/2019/05/10/JVM%E9%9D%A2%E8%AF%95/u=1236259389,1737476709&amp;fm=26&amp;gp=0.jpg" alt="u=1236259389,1737476709&amp;fm=26&amp;gp=0" /></a></p></li>
</ul></li>
</ul>

<h2 id="jvmgc结合springboot微服务优化">JVMGC结合SpringBoot微服务优化</h2>

<p><code>java -server -Xmx1024m -Xmx1024m -XX:+UseG1GC -jar springboot-1.0-SNAPSHOT.war</code></p>

<h2 id="生产环境服务器变慢-诊断思路和性能评估谈谈">生产环境服务器变慢，诊断思路和性能评估谈谈？</h2>

<ul>
<li>整机：top</li>
<li>CPU：vmstat</li>
<li>内存：free</li>
<li>硬盘：df</li>
<li>磁盘IO：iostat</li>
<li>网络IO：ifstat</li>
</ul>

<blockquote>
<p>top，主要看右上角load average（1分钟，5分钟，15分钟平均负载值），uptime，系统性能命令的精简版</p>

<p>vmstate -n 2 3，采样3次时间间隔2s，查看所有cpu核信息（mpstate -P ALL 2），查看每个进程使用cpu的用量分解信息（pidstat -u 1 -p）</p>

<p>free -m，应用程序可用内存数，查看额外（pidstat -p 进程号 -r 采样间隔秒数）</p>

<p>df -h，查看磁盘剩余空间数</p>

<p>iostat -xdk 2 3，util表示一秒钟有百分之几的时间用于I/O操作。</p>

<p>下载ifstat，</p>
</blockquote>

<h2 id="假如生产环境出现-cpu-过高-请谈谈你的分析思路和定位">假如生产环境出现 CPU 过高，请谈谈你的分析思路和定位？</h2>

<ol>
<li><p>先用 top 命令找出 CPU 占比最高的</p></li>

<li><p>ps -ef 或者 jps 进一步定位，得知是一个怎么样的一个后台程序给我们惹事</p></li>

<li><p>定位到具体的线程或代码</p></li>
</ol>

<ul>
<li>ps -mp 11111 -o THREAD,tid,time

<ul>
<li>-m 显示所有的线程</li>
<li>-p 进程使用cpu的时间</li>
<li>-o 该参数后是用户自定义格式</li>
</ul></li>
</ul>

<ol>
<li><p>将需要的线程 ID 转化为 16 进制格式</p></li>

<li><p>jstat &lt;进程ID&gt; | grep &lt;线程ID(16进制)&gt; -A60</p></li>
</ol>

<h2 id="对于-jdk-自带的-jvm-监控和性能分析工具用过哪些-一般机是怎么用到的">对于 JDK 自带的 JVM 监控和性能分析工具用过哪些？一般机是怎么用到的？</h2>

<p>下一篇重点介绍。</p>

<h2 id="参考链接">参考链接</h2>

<ul>
<li><a href="https://time.geekbang.org/column/article/6970">强引用、软引用、弱引用、幻象引用有什么区别？(评论)</a></li>
<li><a href="https://www.jianshu.com/p/548c67aa1bc0">G1从入门到放弃</a></li>
</ul>

<script src="https://utteranc.es/client.js"
        repo="elon0/comment"
        issue-term="pathname"
        label="💬"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Elon</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2019-09-30 14:22
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/hugo%E4%B8%BB%E9%A2%98even/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Hugo主题Even</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">
            <span class="next-text nav-default">Java并发编程</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="https://github.com/Elon0" class="iconfont icon-github" title="github"></a>
  <a href="https://elon0.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> 本站总访问量 <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次 </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> 本站总访客数 <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 人 </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2019
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Elon</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>








</body>
</html>
